<!--
  AudioToText Orchestrator - Simplified main component
  Coordinates child components for recording and transcription functionality
-->
<script>
	import { onMount, onDestroy } from 'svelte';
	import RecordingControls from './RecordingControls.svelte';
	import TranscriptDisplay from './TranscriptDisplay.svelte';
	import RecordingStatus from './RecordingStatus.svelte';
	import TranscriptionEffects from './TranscriptionEffects.svelte';
	import { memoize } from '$lib/utils/performanceUtils';
	import {
		initializeServices,
		// Stores
		isRecording,
		transcriptionText,
		errorMessage,
		hasPermissionError,
		uiActions
	} from '$lib/services';
	import { whisperStatus } from '../../services/transcription/whisper/whisperService';

	// Props - simplified interface
	export let ghostComponent = null;
	export let onPreloadRequest = null;
	export let isPremiumUser = false;

	// Service instances
	let unsubscribers = [];
	let modelReady = false;

	// Subscribe to whisper status to track when model is ready
	$: modelReady = $whisperStatus.isLoaded;

	// Component references
	let recordingControlsRef;

	// Memoized responsive font sizing based on text length
	const getResponsiveFontSize = memoize(
		(text) => {
			if (!text) return 'text-base';

			const wordCount = text.trim().split(/\s+/).length;

			// Use CSS-based responsive sizing rather than JS viewport detection
			if (wordCount <= 5) {
				return 'text-lg sm:text-xl md:text-2xl lg:text-3xl';
			} else if (wordCount <= 15) {
				return 'text-base sm:text-lg md:text-xl';
			} else if (wordCount <= 50) {
				return 'text-sm sm:text-base md:text-lg';
			} else {
				return 'text-xs sm:text-sm md:text-base';
			}
		},
		(text) => (text ? text.length : 0)
	); // Cache by text length

	// Reactive font size based on transcript length
	$: responsiveFontSize = getResponsiveFontSize($transcriptionText);

	// Handler for transcript component events
	async function handleTranscriptEvent(event) {
		const { type, detail } = event;

		// Handle copy to clipboard
		if (type === 'copy' && detail?.text) {
			try {
				await navigator.clipboard.writeText(detail.text);
				// Set clipboard success state
				uiActions.setClipboardSuccess(true);
				// Reset after 2 seconds
				setTimeout(() => {
					uiActions.setClipboardSuccess(false);
				}, 2000);
			} catch (err) {
				console.error('Failed to copy to clipboard:', err);
			}
		}
		// Forward other events to child components as needed
	}

	// Track if user has interacted with the page
	let hasUserInteracted = false;
	let modelLoadStarted = false;

	// Start background model load after first user interaction OR after 3 seconds
	// This gives us the best of both worlds - fast initial page load but models ready when needed
	function startModelLoading() {
		if (modelLoadStarted) return;
		modelLoadStarted = true;

		// Start progressive model loading
		import('$lib/services/transcription/simpleHybridService').then(({ simpleHybridService }) => {
			console.log('🚀 Starting progressive Whisper model download...');
			simpleHybridService.startBackgroundLoad();
		});
	}

	function handleFirstInteraction() {
		if (hasUserInteracted) return;
		hasUserInteracted = true;

		// Remove listeners after first interaction
		if (typeof window !== 'undefined') {
			window.removeEventListener('click', handleFirstInteraction);
			window.removeEventListener('touchstart', handleFirstInteraction);
			window.removeEventListener('keydown', handleFirstInteraction);
		}

		// Start loading immediately on interaction
		startModelLoading();
	}

	// Lifecycle hooks
	onMount(() => {
		// Initialize services
		initializeServices({ debug: false });

		// Wait for first user interaction before loading models
		// This prevents affecting Lighthouse/PageSpeed scores
		if (typeof window !== 'undefined') {
			window.addEventListener('click', handleFirstInteraction, { once: true });
			window.addEventListener('touchstart', handleFirstInteraction, { once: true });
			window.addEventListener('keydown', handleFirstInteraction, { once: true });

			// Also start loading after 3 seconds if no interaction
			// This ensures models are ready when user needs them
			setTimeout(() => {
				if (!modelLoadStarted) {
					console.log('⏰ Auto-starting model load after 3s delay');
					startModelLoading();
				}
			}, 3000);
		}

		// Subscribe to permission denied state to show error modal
		const permissionUnsub = hasPermissionError.subscribe((denied) => {
			if (denied) {
				// Show permission error modal
				uiActions.setPermissionError(true);
			}
		});

		// Add to unsubscribe list
		unsubscribers.push(permissionUnsub);
	});

	// Clean up subscriptions and services
	onDestroy(() => {
		// Unsubscribe from all subscriptions
		unsubscribers.forEach((unsub) => unsub());
	});

	// Export functions for external components
	export function startRecording() {
		if (recordingControlsRef) {
			recordingControlsRef.startRecording();
		}
	}

	export function stopRecording() {
		if (recordingControlsRef) {
			recordingControlsRef.stopRecording();
		}
	}

	export function toggleRecording() {
		if (recordingControlsRef) {
			recordingControlsRef.toggleRecording();
		}
	}

	export const recording = isRecording; // Export the isRecording store

	// Handle when model is required
	function handleModelRequired() {
		// Model initialization is now handled through the whisperService
		console.log('Model required - initialization handled by whisperService');
	}

	function handleModelReady() {
		modelReady = true;
	}
</script>

<!-- Main wrapper - simplified orchestrator layout -->
<div class="main-wrapper mx-auto box-border w-full">
	<!-- Shared container with proper centering for mobile -->
	<div class="mobile-centered-container flex w-full flex-col items-center justify-center">
		<!-- Recording Controls Section -->
		<RecordingControls
			bind:this={recordingControlsRef}
			{ghostComponent}
			{onPreloadRequest}
			{isPremiumUser}
			{modelReady}
			onModelRequired={handleModelRequired}
			on:recordingStateChanged
			on:error
			on:preload
		/>

		<!-- Dynamic content area - only render when there's content -->
		{#if $isRecording || $transcriptionText || $errorMessage}
			<div
				class="content-wrapper relative mb-10 mt-2 flex w-full flex-col items-center transition-all duration-300 ease-in-out"
			>
				<!-- Transcript Display -->
				{#if $transcriptionText && !$isRecording}
					<TranscriptDisplay
						transcript={$transcriptionText}
						{responsiveFontSize}
						on:copy={handleTranscriptEvent}
						on:share={handleTranscriptEvent}
						on:focus={handleTranscriptEvent}
					/>
				{/if}

				<!-- Status and Error Messages -->
				<RecordingStatus />
			</div>
		{/if}
	</div>
</div>

<!-- Transcription Effects (Confetti) -->
<TranscriptionEffects {ghostComponent} targetSelector=".ghost-icon-wrapper" />

<style>
	/* Main wrapper to ensure proper positioning */
	.main-wrapper {
		position: relative;
		z-index: 1;
		width: 100%;
		box-sizing: border-box;
	}

	/* Improved focus styles for keyboard navigation */
	:focus-visible {
		outline: 2px solid #f59e0b;
		outline-offset: 2px;
	}

	/* Apply box-sizing to all elements for consistent layout */
	* {
		box-sizing: border-box;
	}

	/* Mobile-centered container */
	.mobile-centered-container {
		width: 100%;
		max-width: 100vw;
		margin: 0 auto;
		text-align: center;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
	}
</style>

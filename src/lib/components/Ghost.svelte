<script>
	import { onMount, onDestroy } from 'svelte';
	import '../styles/animations/ghost-glows.css';

	// Props to communicate state
	export let isRecording = false;
	export let isProcessing = false;
	export let animationState = 'idle'; // 'idle', 'wobble-start', 'wobble-stop'

	// Custom events
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();

	// Local state
	let blinkTimeoutId = null;
	let wobbleTimeoutId = null;
	let specialAnimationTimeoutId = null;
	let eyesClosed = false;
	let isWobbling = false;
	let isRainbow = false;
	let eyePositionX = 0; // For horizontal eye tracking: -1 to 1
	let eyePositionY = 0; // For vertical eye tracking: -1 to 1
	let doingSpecialAnimation = false; // For rare spin animation (easter egg)
	let currentTheme = 'peach';
	let bgImageSrc = '/talktype-icon-bg-gradient.svg';

	// Mouse tracking
	let ghostElement = null; // Reference to the container element

	// --- Theme handling ---
	onMount(() => {
		// Update theme on mount
		if (typeof document !== 'undefined') {
			updateTheme();

			// Listen for theme changes, but add a short delay for initialization
			setTimeout(() => {
				const observer = new MutationObserver((mutations) => {
					mutations.forEach((mutation) => {
						if (mutation.attributeName === 'data-theme') {
							updateTheme();
						}
					});
				});

				observer.observe(document.documentElement, {
					attributes: true,
					attributeFilter: ['data-theme']
				});
			}, 50);

			// Start greeting animation
			setTimeout(() => {
				greetingAnimation();
			}, 1500);

			// Start tracking mouse movement for eye position
			document.addEventListener('mousemove', trackMousePosition, { passive: true });

			// Start special animation detection (easter egg)
			maybeDoSpecialAnimation();

			return () => {
				observer.disconnect();
				document.removeEventListener('mousemove', trackMousePosition);
				clearTimeout(specialAnimationTimeoutId);
				clearTimeout(wobbleTimeoutId);
			};
		}
	});

	// Clean up on destroy
	onDestroy(() => {
		clearTimeout(blinkTimeoutId);
		clearTimeout(wobbleTimeoutId);
		clearTimeout(specialAnimationTimeoutId);
	});

	// --- Animation Functions ---

	// Greeting animation
	function greetingAnimation() {
		// Use the force wobble animation for greeting
		forceWobble();

		// Then do natural double blink with good vibe after wobble completes
		setTimeout(() => {
			eyesClosed = true;
			setTimeout(() => {
				eyesClosed = false;
				setTimeout(() => {
					eyesClosed = true;
					setTimeout(() => {
						eyesClosed = false;

						// Start ambient blinking
						scheduleBlink();
					}, 150); // More natural close time
				}, 180); // Better pause between blinks
			}, 150); // More natural open time
		}, 600); // Wait for wobble to complete
	}

	// Regular ambient blinking
	function scheduleBlink() {
		clearTimeout(blinkTimeoutId);

		// Don't blink during recording or processing
		if (isRecording || isProcessing) {
			return;
		}

		// Random delay between blinks (4-8 seconds)
		const delay = 4000 + Math.random() * 4000;

		blinkTimeoutId = setTimeout(() => {
			// Single or double blink with good vibe from old commits
			if (Math.random() < 0.25) {
				// Double blink (25% chance) - natural feel
				eyesClosed = true;
				setTimeout(() => {
					eyesClosed = false;
					setTimeout(() => {
						eyesClosed = true;
						setTimeout(() => {
							eyesClosed = false;
							scheduleBlink(); // Schedule next blink
						}, 150); // Original timing
					}, 180); // Smoother between blinks
				}, 150); // Original timing
			} else {
				// Single blink (75% chance) - natural timing
				eyesClosed = true;
				setTimeout(() => {
					eyesClosed = false;
					scheduleBlink(); // Schedule next blink
				}, 150); // Original timing
			}
		}, delay);
	}

	// Theme-specific glow colors - enhanced with peachier and more vibrant colors
	let glowColors = {
		peach: {
			// Extra peachy pink with warm sunset glow - more saturation
			primary: 'rgba(255, 128, 170, 0.95)', // More saturated peachy pink (main)
			secondary: 'rgba(255, 180, 128, 0.9)', // Warmer peach/orange secondary
			tertiary: 'rgba(255, 210, 160, 0.8)' // Soft golden tertiary glow
		},
		mint: {
			// Super fresh candy mint with aqua undertone - more vivid
			primary: 'rgba(70, 255, 180, 0.95)', // More candy-like mint (main)
			secondary: 'rgba(120, 255, 210, 0.9)', // Brighter mint highlight
			tertiary: 'rgba(180, 255, 235, 0.8)' // Aqua-tinted outer glow
		},
		bubblegum: {
			// Enhanced cotton-candy purple with deeper saturation
			primary: 'rgba(190, 130, 255, 0.95)', // More vibrant purple main color
			secondary: 'rgba(220, 160, 255, 0.9)', // Softer purple highlight
			tertiary: 'rgba(240, 200, 255, 0.8)' // Dreamy outer glow
		},
		rainbow: {
			// Rainbow gets special golden sparkle treatment
			primary: 'rgba(255, 215, 0, 0.95)', // Gold/amber main color
			secondary: 'rgba(255, 245, 200, 0.9)', // Soft gold highlight
			tertiary: 'rgba(255, 255, 200, 0.8)' // Pale gold outer glow
		}
	};

	// Current theme's glow colors
	let currentGlowColors = glowColors.peach;

	// Update theme based on document attribute
	function updateTheme() {
		if (typeof document !== 'undefined') {
			currentTheme = document.documentElement.getAttribute('data-theme') || 'peach';
			isRainbow = currentTheme === 'rainbow';

			// Update glow colors based on theme
			currentGlowColors = glowColors[currentTheme] || glowColors.peach;

			switch (currentTheme) {
				case 'mint':
					bgImageSrc = '/talktype-icon-bg-gradient-mint.svg';
					break;
				case 'bubblegum':
					bgImageSrc = '/talktype-icon-bg-gradient-bubblegum.svg';
					break;
				case 'rainbow':
					bgImageSrc = '/talktype-icon-bg-gradient-rainbow.svg';
					break;
				default: // Default to peach
					bgImageSrc = '/talktype-icon-bg-gradient.svg';
					break;
			}
		}
	}

	// Special animations that rarely happen (easter egg)
	function maybeDoSpecialAnimation() {
		if (typeof window === 'undefined') return;

		clearTimeout(specialAnimationTimeoutId);

		// Very rare animation (5% chance when conditions are right)
		if (
			Math.random() < 0.05 &&
			!isRecording &&
			!isProcessing &&
			!doingSpecialAnimation &&
			!eyesClosed
		) {
			doingSpecialAnimation = true;

			// Do a special animation (full spin)
			// We'll handle this with CSS animation classes

			// Return to normal after animation
			setTimeout(() => {
				doingSpecialAnimation = false;
			}, 2000);
		}

		// Schedule next check
		specialAnimationTimeoutId = setTimeout(maybeDoSpecialAnimation, 45000); // Check every 45 seconds
	}

	// Track mouse movement to move eyes
	function trackMousePosition(event) {
		if (typeof window === 'undefined' || !ghostElement || eyesClosed) return; // Allow tracking during recording for better tactility

		// Get ghost element bounding box
		const ghostRect = ghostElement.getBoundingClientRect();
		const ghostCenterX = ghostRect.left + ghostRect.width / 2;
		const ghostCenterY = ghostRect.top + ghostRect.height / 2;

		// Calculate mouse position relative to ghost center
		const mouseX = event.clientX;
		const mouseY = event.clientY;
		const distanceX = mouseX - ghostCenterX;
		const distanceY = mouseY - ghostCenterY;

		// Normalize to values between -1 and 1
		const maxDistanceX = window.innerWidth / 3; // More responsive horizontal tracking
		const maxDistanceY = window.innerHeight / 3; // Vertical tracking
		const normalizedX = Math.max(-1, Math.min(1, distanceX / maxDistanceX));
		const normalizedY = Math.max(-1, Math.min(1, distanceY / maxDistanceY));

		// Add smaller dead zone for more responsiveness
		if (Math.abs(normalizedX) < 0.05) {
			eyePositionX = 0;
		} else {
			// Apply faster smoothing for better tactility - 20% toward target
			eyePositionX = eyePositionX + (normalizedX - eyePositionX) * 0.2;
		}

		// Vertical tracking with smaller movement range
		if (Math.abs(normalizedY) < 0.05) {
			eyePositionY = 0;
		} else {
			// Apply faster smoothing for better tactility - 20% toward target
			eyePositionY = eyePositionY + (normalizedY - eyePositionY) * 0.2;
		}
	}

	// Dispatch toggle recording event when clicked
	function handleClick() {
		// Only dispatch the event - parent will handle animation state
		console.log('ðŸ‘» Ghost clicked - dispatching toggleRecording event');
		dispatch('toggleRecording');
	}

	// Public methods to expose animation controls
	export function pulse() {
		// Add subtle pulse animation
		if (ghostElement) {
			ghostElement.classList.add('ghost-pulse');
			setTimeout(() => {
				ghostElement.classList.remove('ghost-pulse');
			}, 600); // Pulse duration
		}
	}

	export function startThinking() {
		// Add thinking hard animation for eyes
		if (ghostElement) {
			const eyes = ghostElement.querySelector('.icon-eyes');
			if (eyes) {
				eyes.classList.add('blink-thinking-hard');
			}
		}
	}

	export function stopThinking() {
		// Remove thinking hard animation
		if (ghostElement) {
			const eyes = ghostElement.querySelector('.icon-eyes');
			if (eyes) {
				eyes.classList.remove('blink-thinking-hard');
			}
		}
	}

	export function reactToTranscript(textLength = 0) {
		// Skip if no element
		if (!ghostElement) return;

		const eyes = ghostElement.querySelector('.icon-eyes');
		if (!eyes) return;

		if (textLength > 20) {
			// For longer transcripts, do a "satisfied" double blink
			setTimeout(() => {
				eyes.classList.add('blink-once');
				setTimeout(() => {
					eyes.classList.remove('blink-once');
					setTimeout(() => {
						eyes.classList.add('blink-once');
						setTimeout(() => {
							eyes.classList.remove('blink-once');
						}, 200); // Thinking blink rate
					}, 200); // Thinking blink rate
				}, 200); // Thinking blink rate
			}, 500); // Reaction delay
		} else if (textLength > 0) {
			// For short transcripts, just do a single blink
			setTimeout(() => {
				eyes.classList.add('blink-once');
				setTimeout(() => {
					eyes.classList.remove('blink-once');
				}, 300); // Single blink duration
			}, 500); // Reaction delay
		}
	}

	// Function to force wobble animation - works with both direct calls and animation state
	export function forceWobble(direction = '', isStartRecording = false) {
		// Make sure we're in browser context
		if (typeof window === 'undefined') return;

		console.log('ðŸ‘» FORCE WOBBLE triggered', isStartRecording ? '(start recording)' : '');

		// Force animation restart by setting to false first
		isWobbling = false;

		// Force a browser reflow to ensure the animation gets reapplied
		if (ghostElement) {
			void ghostElement.offsetWidth;
		}

		// Now set to true to start animation
		isWobbling = true;

		// Clear any existing wobble timer
		clearTimeout(wobbleTimeoutId);

		// Schedule the wobble to end after animation completes
		wobbleTimeoutId = setTimeout(() => {
			isWobbling = false;
		}, 600);
	}

	// Track previous state to detect actual changes
	let wasRecording = false;
	let wasProcessing = false;

	// Watch for animation state changes
	$: {
		console.log(`ðŸ‘» Animation state: ${animationState}`);

		// Apply animations based on animation state
		if (animationState === 'wobble-start') {
			console.log('ðŸ‘» START wobble animation');
			forceWobble('', true);
		} else if (animationState === 'wobble-stop') {
			console.log('ðŸ‘» STOP wobble animation');
			forceWobble();
		}
	}

	// Watch for changes in recording/processing state - only for blinking
	$: {
		// Track previous state for blink management
		const wasRecordingTemp = wasRecording;
		const wasProcessingTemp = wasProcessing;

		// Blink handling
		if (isRecording || isProcessing) {
			// Clear any scheduled blinks during recording/processing
			clearTimeout(blinkTimeoutId);
		} else if ((wasRecordingTemp || wasProcessingTemp) && !isRecording && !isProcessing) {
			// Restart blinking after a delay when we're fully stopped
			setTimeout(() => {
				scheduleBlink();
			}, 1000);
		}

		// Update previous state for next comparison
		wasRecording = isRecording;
		wasProcessing = isProcessing;
	}
</script>

<button
	bind:this={ghostElement}
	class="icon-container theme-{currentTheme} 
		{isRecording ? 'recording recording-theme-' + currentTheme + ' ghost-recording-glow-' + currentTheme : ''}
		{isWobbling ? 'ghost-wobble-' + (Math.random() > 0.5 ? 'left' : 'right') : ''} 
		{doingSpecialAnimation ? 'do-special-animation' : ''}"
	on:click={handleClick}
	on:keydown={(e) => {
		if (e.key === 'Enter' || e.key === ' ') {
			e.preventDefault();
			handleClick();
		}
	}}
	aria-label="Toggle Recording"
	aria-pressed={isRecording.toString()}
>
	<div class="icon-layers">
		<!-- Background gradient -->
		<img src={bgImageSrc} alt="" class="icon-bg {isRainbow ? 'rainbow-animated' : ''}" />

		<!-- Base ghost image -->
		<img src="/assets/talktype-icon-base.svg" alt="" class="icon-base" />

		<!-- Eyes - controlled by local state with transform-based blinking -->
		<img
			src="/assets/talktype-icon-eyes.svg"
			alt=""
			class="icon-eyes {eyesClosed ? 'eyes-closed' : ''}"
			style={eyesClosed
				? 'transform: scaleY(0.05);'
				: `transform: translate(${eyePositionX * 4}px, ${eyePositionY * 2}px);`}
		/>
	</div>
</button>

<style>
	.icon-container {
		position: relative;
		width: 100%;
		height: 100%;
		cursor: pointer;
		background: transparent;
		border: none;
		outline: none;
		-webkit-tap-highlight-color: transparent;
		/* Default filter removed to avoid conflicts with ghost-glows.css */
		transition: all 0.8s cubic-bezier(0.19, 1, 0.22, 1);
		animation: gentle-float 3s ease-in-out infinite;
		animation-delay: 2.5s;
		transform: translateY(0);
		opacity: 1;
	}

	.icon-container:focus,
	.icon-container:active,
	.icon-container:focus-visible {
		outline: none !important;
		outline-offset: 0 !important;
		box-shadow: none !important;
		border: none !important;
	}

	.icon-layers {
		position: relative;
		width: 100%;
		height: 100%;
	}

	.icon-bg,
	.icon-base,
	.icon-eyes {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		transition: all 0.3s ease;
		user-select: none;
		-webkit-user-drag: none;
		animation: grow-ghost 2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
		transform-origin: center center;
	}

	/* Stack layers correctly with synchronized animations */
	.icon-bg {
		z-index: 1; /* Bottom layer */
		animation-delay: 0s;
	}

	.icon-base {
		z-index: 2; /* Middle layer */
		animation-delay: 0s; /* Synchronized with bg */
	}

	.icon-eyes {
		z-index: 3; /* Top layer */
		transform-origin: center center;
		transition: transform 0.08s ease-out; /* More natural blink timing */
		will-change: transform; /* GPU acceleration hint */
		transform: translateZ(0); /* Force GPU rendering */
		animation-delay: 0s; /* Synchronized with other layers */
	}

	/* Hover effects - just subtle movement, all glow comes from ghost-glows.css */
	.icon-container:hover,
	.icon-container:active {
		animation: ghost-hover 1.2s ease-in-out infinite alternate;
		animation-delay: 0s;
		/* No filters here - all glow effects come from ghost-glows.css */
	}

	/* Recording state styles managed in ghost-glows.css */

	/* Wobble animations */
	.ghost-wobble-left {
		animation: ghost-wobble-left 0.6s ease-in-out forwards !important;
	}

	.ghost-wobble-right {
		animation: ghost-wobble-right 0.6s ease-in-out forwards !important;
	}

	/* Eyes closed state - transform-based with natural feel */
	.eyes-closed {
		transform: scaleY(0.05) !important; /* Not too extreme closure */
		transition: transform 0.08s ease-out !important; /* Smoother, more natural close */
	}

	/* Single blink animation class */
	.blink-once {
		transform: scaleY(0.05) !important;
		transition: transform 0.08s ease-out !important;
	}

	/* Thinking hard animation */
	.blink-thinking-hard {
		animation: thinking-hard 1.5s ease-in-out infinite !important;
	}

	/* Ghost pulse animation */
	.ghost-pulse {
		animation: ghost-pulse 0.6s ease-in-out forwards !important;
	}

	@keyframes thinking-hard {
		0%,
		10%,
		90%,
		100% {
			transform: scaleY(1);
		}
		20%,
		25% {
			transform: scaleY(0.1);
		}
		30%,
		35% {
			transform: scaleY(1);
		}
		40%,
		45% {
			transform: scaleY(0.1);
		}
		50%,
		85% {
			transform: scaleY(1);
		}
	}

	@keyframes ghost-pulse {
		0% {
			transform: scale(1);
		}
		50% {
			transform: scale(1.05);
		}
		100% {
			transform: scale(1);
		}
	}

	/* Rainbow animation for ghost svg */
	.rainbow-animated {
		animation: 
			grow-ghost 2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
			rainbowFlow 9s cubic-bezier(0.4, 0, 0.6, 1) 2s infinite;
		transform-origin: center bottom;
		/* Filter removed to avoid conflicts with ghost-glows.css */
	}

	.icon-container:hover .rainbow-animated {
		animation:
			grow-ghost 2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
			rainbowFlow 6s cubic-bezier(0.4, 0, 0.6, 1) 2s infinite;
		/* Filter and sparkle animation removed to avoid conflicts with ghost-glows.css */
	}

	/* Base animations */
	@keyframes gentle-float {
		0%,
		10%,
		90%,
		100% {
			transform: translateY(0);
		}
		50% {
			transform: translateY(-3px);
		}
	}

	@keyframes ghost-hover {
		0% {
			transform: scale(1.005) translateY(0);
		}
		100% {
			transform: scale(1.015) translateY(-3px);
		}
	}

	/* Pulsing scale animation moved to ghost-glows.css */

	@keyframes ghost-wobble-left {
		0% {
			transform: rotate(0deg) scale(1);
		}
		25% {
			transform: rotate(-5deg) scale(1.02);
		}
		50% {
			transform: rotate(3deg) scale(1.01);
		}
		75% {
			transform: rotate(-2deg) scale(1.01);
		}
		100% {
			transform: rotate(0deg) scale(1);
		}
	}

	@keyframes ghost-wobble-right {
		0% {
			transform: rotate(0deg) scale(1);
		}
		25% {
			transform: rotate(5deg) scale(1.02);
		}
		50% {
			transform: rotate(-3deg) scale(1.01);
		}
		75% {
			transform: rotate(2deg) scale(1.01);
		}
		100% {
			transform: rotate(0deg) scale(1);
		}
	}

	@keyframes rainbowFlow {
		0% { 
			filter: hue-rotate(0deg) saturate(1.4) brightness(1.15);
			transform: scale(1.0);
		}
		20% { 
			filter: hue-rotate(72deg) saturate(1.6) brightness(1.18);
			transform: scale(1.005);
		}
		50% { 
			filter: hue-rotate(180deg) saturate(1.7) brightness(1.22);
			transform: scale(1.012);
		}
		80% { 
			filter: hue-rotate(288deg) saturate(1.6) brightness(1.2);
			transform: scale(1.005);
		}
		100% { 
			filter: hue-rotate(360deg) saturate(1.4) brightness(1.15);
			transform: scale(1.0);
		}
	}

	@keyframes sparkle {
		0%,
		100% {
			filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.7))
				drop-shadow(0 0 8px rgba(255, 61, 127, 0.6));
		}
		25% {
			filter: drop-shadow(0 0 6px rgba(255, 141, 60, 0.8))
				drop-shadow(0 0 10px rgba(255, 249, 73, 0.7));
		}
		50% {
			filter: drop-shadow(0 0 6px rgba(77, 255, 96, 0.7))
				drop-shadow(0 0 9px rgba(53, 222, 255, 0.7));
		}
		75% {
			filter: drop-shadow(0 0 7px rgba(159, 122, 255, 0.8))
				drop-shadow(0 0 9px rgba(255, 61, 127, 0.6));
		}
	}

	@keyframes grow-ghost {
		0% {
			transform: scale(0);
			opacity: 0;
		}
		30% {
			opacity: 1;
		}
		70% {
			transform: scale(1.1);
		}
		85% {
			transform: scale(0.95);
		}
		100% {
			transform: scale(1);
			opacity: 1;
		}
	}

	/* Media queries for larger screens - filter removed to avoid conflicts */
	@media (min-width: 768px) {
		.icon-container {
			/* No filter here to avoid conflicts with ghost-glows.css */
		}
	}
</style>